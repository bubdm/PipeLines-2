// <auto-generated />
using PipeLines.Model;
using PipeLines.Model.PipeItemModels;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using System.Windows;
using System.Windows.Controls;
using System.Windows.Data;
using System.Windows.Documents;
using System.Windows.Input;
using System.Windows.Media;
using System.Windows.Media.Animation;
using System.Windows.Media.Imaging;
using System.Windows.Shapes;
using System.Drawing;
using PipeLines.ViewModel;
using System.Windows.Threading;

namespace PipeLines
{
    /// <summary>
    /// In this class, a gameLevel will be created. It will place UI elements (Image objects) on a canvas, and connect them to PipeItem objects.
    /// This class handles mouse events and evaluates after every mouse movement, whether the solution is ready.
    /// </summary>
    public partial class GameWindow : Window
    {
        GameWindowViewModel gamewvm;
        Dictionary<Image, PipeItem> itemDictionary;
        GameLevel gameLevel;
        /// <summary>
        /// Left click - Horizontal movement
        /// Right click - Vertical movement
        /// </summary>
        enum MouseMoveDirection
        {
            Horizontal,
            Vertical
        }
        bool activated = false; //mouseDown method will activate
        Point point; //actual coordinate of the mouse inside of an Image object
        MouseMoveDirection actualDirection;
        bool endoftheGame;

        /// <summary>
        /// Variables for calculating a grid layout
        /// </summary>        
        int gridCount; 
        double[] columnStartingCoordinates;
        double[] rowStartingCoordinates;
        double columnWidth;
        double rowHeight;
        Image[,] gameMap;
        

        /// <summary>
        /// Variables for collision detection
        /// </summary>
        int[] actualCell;
        Point pointOnCanvas;
        double leftNeighboorCoordinate;
        double rightNeighboorCoordinate;
        double topNeighboorCoordinate;
        double bottomNeighboorCoordinate;
        bool onlyRunsOnceInMouseMove;

        /// <summary>
        /// Variables for animation
        /// </summary>
        List<PipeItem> solutionList; 
        List<PipeItem> solutionListOtherDirection;
        Image finalItem;
        


        public GameWindow(LevelNumber level, GameWindowViewModel view)
        {
            InitializeComponent();

            this.gamewvm = view;
            gameLevel = new GameLevel(level);
            gridCount = gameLevel.GridCount;
            CalculateGridCell();
            CreateGameMap();
            endoftheGame = false;
        }
        /// <summary>
        /// Initial event, when an Image item is clicked on the canvas
        /// </summary>
        /// <param name="sender"></param>
        /// <param name="e"></param>
        private void image_MouseDown(object sender, MouseButtonEventArgs e)
        {
            if (!activated && !endoftheGame)
            {
                if (e.ChangedButton == MouseButton.Left)
                {
                    actualDirection = MouseMoveDirection.Horizontal;
                    horizontalLabel.Visibility = Visibility.Visible;
                }
                else if (e.ChangedButton == MouseButton.Right)
                {
                    actualDirection = MouseMoveDirection.Vertical;
                    verticalLabel.Visibility = Visibility.Visible;
                }

                activated = true;
                point = Mouse.GetPosition((Image)sender);
                pointOnCanvas = Mouse.GetPosition(myCanvas);
                Mouse.Capture((Image)sender);
                                
                actualCell = findGridCell(pointOnCanvas.X, pointOnCanvas.Y); //store the initial position of the moveable item

                //after every movement, an animation helps positioning the item, if it is not correctly in its place
                //the previous animation properties have to be deleted, in order to move the item again
                Image movedImage = (Image)sender;
                movedImage.BeginAnimation(Canvas.LeftProperty, null);
                movedImage.BeginAnimation(Canvas.TopProperty, null);

            
                DetectCollision();
            }

        }
        /// <summary>
        /// MouseUp method will follow the MouseDown method (while the mousebutton is pressed)
        /// The coordinates of the moved item will follow the mouse movement
        /// This method gets top, bottom, left and right limits from the DetectCollision method in the MouseDown. 
        /// If the moved item coordinates reach the limits, there is a collision, and the movement will stop in this direction.
        /// </summary>
        /// <param name="sender"></param>
        /// <param name="e"></param>
        private void image_MouseMove(object sender, MouseEventArgs e)
        {
            if (activated && !endoftheGame)
            {
                double top = Canvas.GetTop((Image)sender) + Mouse.GetPosition((Image)sender).Y - point.Y;
                
                if (actualDirection == MouseMoveDirection.Vertical)
                {
                    Canvas.SetTop((Image)sender, top);  
                    if (top < topNeighboorCoordinate) //collides with the the top item
                    {
                        Canvas.SetTop((Image)sender, topNeighboorCoordinate);
                    }
                    else if (top + rowHeight > bottomNeighboorCoordinate) //collides with the bottom item
                    {
                        Canvas.SetTop((Image)sender, bottomNeighboorCoordinate - rowHeight);
                    }
                }

                double left = Canvas.GetLeft((Image)sender) + Mouse.GetPosition((Image)sender).X - point.X;
                if (actualDirection == MouseMoveDirection.Horizontal)
                {
                    Canvas.SetLeft((Image)sender, left);  //collides with the left item              
                    if (left < leftNeighboorCoordinate) 
                    {
                        Canvas.SetLeft((Image)sender, leftNeighboorCoordinate);
                    }
                    else if (left + columnWidth > rightNeighboorCoordinate) //collides with the right item      
                    {
                        Canvas.SetLeft((Image)sender, rightNeighboorCoordinate - columnWidth);
                    }
                }
            }
        }
        /// <summary>
        /// MouseUp will handle the changes in the item position. 
        /// It will finish the movement, if the item is not placed correctly in a cell. 
        /// 
        /// </summary>
        /// <param name="sender"></param>
        /// <param name="e"></param>
        private void image_MouseUp(object sender, MouseButtonEventArgs e)
        {
            if(!endoftheGame)
            {
                verticalLabel.Visibility = Visibility.Hidden;
                horizontalLabel.Visibility = Visibility.Hidden;
                Image actualImage = (Image)sender;
                var mousePosition = e.GetPosition(this);

                int[] whichCell = new int[2];
                if (actualDirection == MouseMoveDirection.Horizontal)
                {
                    double y = Canvas.GetTop(actualImage) + 5; 
                    double x;
                    if (mousePosition.X < leftNeighboorCoordinate)
                        x = leftNeighboorCoordinate + 5;
                    else if (mousePosition.X > rightNeighboorCoordinate)
                        x = rightNeighboorCoordinate - 5;
                    else
                        x = mousePosition.X;

                    whichCell = findGridCell(x, y);
                }
                else if (actualDirection == MouseMoveDirection.Vertical)
                {
                    double x = Canvas.GetLeft(actualImage) + 5;
                    double y;
                    if (mousePosition.Y < topNeighboorCoordinate)
                        y = topNeighboorCoordinate + 5;
                    else if (mousePosition.Y > bottomNeighboorCoordinate)
                        y = bottomNeighboorCoordinate - 5;
                    else
                        y = mousePosition.Y;

                    whichCell = findGridCell(x, y);
                }
                
                //The next IF and ELSE conditions will finish the movement, if the item is not placed correctly in a cell
                if (actualDirection == MouseMoveDirection.Horizontal && (mousePosition.X < rightNeighboorCoordinate) && (mousePosition.X > leftNeighboorCoordinate))               
                {
                    double left = Canvas.GetLeft((Image)sender);
                    double columnCoordinate = columnStartingCoordinates[whichCell[0]];

                    DoubleAnimation myDoubleAnimation = new DoubleAnimation();
                    myDoubleAnimation.From = left;
                    myDoubleAnimation.To = columnCoordinate;
                    myDoubleAnimation.Duration = new Duration(TimeSpan.FromSeconds(0.5 * (Math.Abs(left - columnCoordinate) / columnWidth)));

                    Storyboard myStoryboard = new Storyboard();
                    myStoryboard.Children.Add(myDoubleAnimation);
                    Storyboard.SetTargetName(myDoubleAnimation, actualImage.Name);
                    Storyboard.SetTargetProperty(myDoubleAnimation, new PropertyPath("(Canvas.Left)"));

                    myStoryboard.Children.Add(myDoubleAnimation);

                    myStoryboard.Begin(this);
                    Canvas.SetLeft(actualImage, columnCoordinate);

                }
                else if (actualDirection == MouseMoveDirection.Vertical && (mousePosition.Y > topNeighboorCoordinate) && (mousePosition.Y < bottomNeighboorCoordinate))                
                {
                    double top = Canvas.GetTop((Image)sender);
                    double rowCoordinate = rowStartingCoordinates[whichCell[1]];

                    DoubleAnimation myDoubleAnimation1 = new DoubleAnimation();
                    myDoubleAnimation1.From = top;
                    myDoubleAnimation1.To = rowCoordinate;
                    myDoubleAnimation1.Duration = new Duration(TimeSpan.FromSeconds(0.5 * (Math.Abs(top - rowCoordinate) / columnWidth)));

                    Storyboard myStoryboard = new Storyboard();
                    myStoryboard.Children.Add(myDoubleAnimation1);
                    Storyboard.SetTargetName(myDoubleAnimation1, actualImage.Name);
                    Storyboard.SetTargetProperty(myDoubleAnimation1, new PropertyPath("(Canvas.Top)"));

                    myStoryboard.Children.Add(myDoubleAnimation1);

                    myStoryboard.Begin(this);
                    Canvas.SetTop(actualImage, rowCoordinate);

                }
                //if there was an actual change in the containing cell, the item will be moved inside the array
                //SolutionCheck method will also be called, which returns TRUE, if the user found the solution
                ///if the solution is found, endoftheGame will be TRUE, and items can no longer be moved on the canvas
                if (!(whichCell[0] == actualCell[0] && whichCell[1] == actualCell[1]) && gameMap[whichCell[1], whichCell[0]] == null)
                {
                    Image uj = actualImage;
                    actualImage = new Image();
                    actualImage = null;
                    gameMap[whichCell[1], whichCell[0]] = uj; //new position of the item

                    gameMap[actualCell[1], actualCell[0]] = actualImage; //delete from old position
                    itemDictionary[uj].Posx = whichCell[0];
                    itemDictionary[uj].PosY = whichCell[1];
                    gamewvm.MoveCount++;
                    if (SolutionCheck())
                    {
                        FinalAnimation(0, solutionList);
                        endoftheGame = true;
                    }

                }
                activated = false;
                Mouse.Capture(null);
                onlyRunsOnceInMouseMove = false;
            }            

        }

        /// <summary>
        /// Calculating grid layout on the canvas. Starting coordinates for rows and columns are stored. 
        /// Important for correct item placement on the canvas.
        /// </summary>
        private void CalculateGridCell()
        {
            columnWidth = myCanvas.Width / gridCount;
            rowHeight = columnWidth;

            columnStartingCoordinates = new double[gridCount];
            columnStartingCoordinates[0] = 0;
            for (int i = 1; i < columnStartingCoordinates.Length; i++)
            {
                columnStartingCoordinates[i] = columnStartingCoordinates[i - 1] + columnWidth;
                Console.WriteLine(columnStartingCoordinates[i].ToString());
            }

            rowStartingCoordinates = new double[gridCount];
            rowStartingCoordinates[0] = 0;
            for (int i = 1; i < rowStartingCoordinates.Length; i++)
            {
                rowStartingCoordinates[i] = rowStartingCoordinates[i - 1] + rowHeight;
                Console.WriteLine(rowStartingCoordinates[i].ToString());
            }
        }
        /// <summary>
        /// This method will place the actual Image objects on the canvas, according to the GameLevel ItemMap configuration
        /// </summary>
        private void CreateGameMap()
        {
            gameMap = new Image[gridCount, gridCount];
            CreateFinishItem();
            
            itemDictionary = new Dictionary<Image, PipeItem>();
            PipeItem.Dictionary = itemDictionary;

            for (int i = 0; i < gridCount; i++)
            {
                for (int j = 0; j < gridCount; j++)
                {
                    if (gameLevel.ItemMap[i, j] != null)
                    {
                        Image img = new Image();
                        this.RegisterName(("img" + i + "_" + j).ToString(), img);
                        img.Name = ("img" + i + "_" + j).ToString();
                        myCanvas.Children.Add(img);
                        Canvas.SetTop(img, rowStartingCoordinates[i]);
                        Canvas.SetLeft(img, columnStartingCoordinates[j]);
                        img.Height = rowHeight;
                        img.Width = columnWidth;
                        gameMap[i, j] = img;

                        if (!(gameLevel.ItemMap[i, j] is StartPipe) && !(gameLevel.ItemMap[i, j] is FinishPipe))
                        {
                            img.MouseDown += image_MouseDown;
                            img.MouseMove += image_MouseMove;
                            img.MouseUp += image_MouseUp;
                        }
                        else
                        {
                            img.Stretch = Stretch.Fill;
                            img.Height = 115;
                            img.VerticalAlignment = VerticalAlignment.Top;
                        }

                        gameLevel.ItemMap[i, j].setImageSource(img);
                    }
                }
            }
        }
        /// <summary>
        /// This method returns an int array. It can determine, which cell contains an X, Y coordinate.
        /// </summary>
        /// <param name="xCoord"></param>
        /// <param name="yCoord"></param>
        /// <returns></returns>
        private int[] findGridCell(double xCoord, double yCoord)
        {
            int[] gridIndexes = new int[2]; //az első index az oszlop, a második pedig a sor

            int i = 0;
            while (columnStartingCoordinates[i] + columnWidth < xCoord)
            {
                i++;
            }
            gridIndexes[0] = i;

            int j = 0;
            while (rowStartingCoordinates[j] + rowHeight < yCoord)
            {
                j++;
            }
            gridIndexes[1] = j;

            return gridIndexes;
        }
        /// <summary>
        /// DetectCollision method will determine the limits for the MouseMove method
        /// It will give collision coordinates for both Horizontal and Vertical movement
        /// </summary>
        private void DetectCollision()
        {
            if (!onlyRunsOnceInMouseMove)
            {
                onlyRunsOnceInMouseMove = true;

                if (actualDirection == MouseMoveDirection.Horizontal)
                {
                    int x = actualCell[0];
                    leftNeighboorCoordinate = 0;
                    rightNeighboorCoordinate = myCanvas.Width;
                    for (int i = 0; i < x; i++)
                    {
                        if (gameMap[actualCell[1], i] != null)
                        {
                            leftNeighboorCoordinate = columnStartingCoordinates[i] + columnWidth; 
                        }
                    }
                    bool closestRightFound = false;
                    for (int j = x + 1; j < gridCount; j++)
                    {
                        if (gameMap[actualCell[1], j] != null && !closestRightFound)
                        {
                            rightNeighboorCoordinate = columnStartingCoordinates[j];
                            closestRightFound = true;
                        }
                    }
                }
                else if (actualDirection == MouseMoveDirection.Vertical)
                {
                    int y = actualCell[1];
                    topNeighboorCoordinate = 0;
                    bottomNeighboorCoordinate = rowStartingCoordinates[gridCount - 1] + rowHeight;
                    for (int i = 0; i < y; i++)
                    {
                        if (gameMap[i, actualCell[0]] != null)
                        {
                            topNeighboorCoordinate = rowStartingCoordinates[i] + rowHeight;
                        }
                    }
                    bool closestBottomFound = false;
                    for (int j = y + 1; j < gridCount; j++)
                    {
                        if (gameMap[j, actualCell[0]] != null && !closestBottomFound)
                        {
                            bottomNeighboorCoordinate = columnStartingCoordinates[j]; 
                            closestBottomFound = true;
                        }
                    }
                }
            }

        }


      /// <summary>
      /// Variables used for the final water animation
      /// </summary>
        Image waterBackground;
        Image waterBackground2;        
        bool endWindowShow = true;
        int animatedItemIndex = 1;
        int otherDirectionIndex = 0;
        bool crossing = false; //if true, it means the water flowing through a T-shape item, so it has to continue in 2 ways
        /// <summary>
        /// Animation for one item is finished. It will call the animation for the next item
        /// It also handles the end of the game, if there is no more item in the list
        /// </summary>
        /// <param name="sender"></param>
        /// <param name="e"></param>
        private void animationCompleted(object sender, EventArgs e)
        {
            waterBackground.OpacityMask = null;
            if (waterBackground2 != null)
                waterBackground2.OpacityMask = null;
            if (animatedItemIndex + otherDirectionIndex < gameLevel.PipeElementCount)
            {
                if (!crossing)
                    FinalAnimation(animatedItemIndex++, solutionList);
                else
                {
                    if (otherDirectionIndex < solutionListOtherDirection.Count())
                        FinalAnimation(animatedItemIndex++, otherDirectionIndex++, solutionList, solutionListOtherDirection);
                    else
                        FinalAnimation(animatedItemIndex++, solutionList);
                }
            }
            else if(endWindowShow)
            {
                finishItemAnimation();
                endMenu.Visibility = Visibility.Visible;
                endWindowShow = false;
            }
            
        }
        /// <summary>
        /// Call animation for one item
        /// </summary>
        /// <param name="i"></param>
        /// <param name="list"></param>
        private void FinalAnimation(int i, List<PipeItem> list)
        {
            myStoryBoard.Begin();

            AnimatingItem(list[i], null, false);

            if ((list[i] is TShapeBottomPipe || list[i] is TShapeTopPipe))
                crossing = true;
        }
        /// <summary>
        /// If there was a crossing, animation have to run parallel, two items at one time
        /// </summary>
        /// <param name="i"></param>
        /// <param name="j"></param>
        /// <param name="list"></param>
        /// <param name="list2"></param>
        private void FinalAnimation(int i, int j, List<PipeItem> list, List<PipeItem> list2)
        {
            myStoryBoard.Begin();

            if(i<list.Count && j<list2.Count)
                AnimatingItem(list[i], list2[j], true);
            else if (i<list.Count)
                AnimatingItem(list[i], null, false);
            else if(j<list2.Count)
                AnimatingItem(list2[j],null, false);

        }
        private void AnimatingItem(PipeItem animatedItem, PipeItem secondItem, bool isCrossing)
        {
            waterBackground = new Image();
            Canvas.SetLeft(waterBackground, Canvas.GetLeft(gameMap[animatedItem.PosY, animatedItem.Posx]));
            Canvas.SetTop(waterBackground, Canvas.GetTop(gameMap[animatedItem.PosY, animatedItem.Posx]));
            waterBackground.Source = new BitmapImage(animatedItem.WaterBackgroundSource);
            waterBackground.Height = gameMap[animatedItem.PosY, animatedItem.Posx].ActualHeight;
            waterBackground.Width = gameMap[animatedItem.PosY, animatedItem.Posx].ActualWidth;
            waterBackground.VerticalAlignment = VerticalAlignment.Top;
            myCanvas.Children.Add(waterBackground); 
            Canvas.SetZIndex(gameMap[animatedItem.PosY, animatedItem.Posx], 1);
            transparentMask.From = 0;
            blackMask.From = 0;

            //choosing direction
            opacityMask.StartPoint = animatedItem.AnimationStartPoint;
            opacityMask.EndPoint = animatedItem.AnimationEndPoint;

            waterBackground.OpacityMask = opacityMask;

            if (isCrossing)
            {
                waterBackground2 = new Image();
                Canvas.SetLeft(waterBackground2, Canvas.GetLeft(gameMap[secondItem.PosY, secondItem.Posx]));
                Canvas.SetTop(waterBackground2, Canvas.GetTop(gameMap[secondItem.PosY, secondItem.Posx]));
                waterBackground2.Source = new BitmapImage(secondItem.WaterBackgroundSource);
                waterBackground2.Height = gameMap[secondItem.PosY, secondItem.Posx].ActualHeight;
                waterBackground2.Width = gameMap[secondItem.PosY, secondItem.Posx].ActualWidth;
                waterBackground2.VerticalAlignment = VerticalAlignment.Top;
                myCanvas.Children.Add(waterBackground2);
                Canvas.SetZIndex(gameMap[secondItem.PosY, secondItem.Posx], 1);
                transparentMask.From = 0;
                blackMask.From = 0;
                waterBackground2.OpacityMask = opacityMask;
            }           

        }
        private void finishItemAnimation()
        {
            myStoryBoard.Begin();
            waterBackground = new Image();
            Canvas.SetLeft(waterBackground, Canvas.GetLeft(finalItem));
            Canvas.SetTop(waterBackground, Canvas.GetTop(finalItem)+2);
            waterBackground.Source = new BitmapImage(new Uri("Assets/horizontal_water.png", UriKind.Relative));
            waterBackground.Height = finalItem.Height;
            waterBackground.Width = 50;
            waterBackground.VerticalAlignment = VerticalAlignment.Center;
            waterBackground.HorizontalAlignment = HorizontalAlignment.Left;
            waterBackground.Stretch = Stretch.Fill;
            myCanvas.Children.Add(waterBackground); 
            Canvas.SetZIndex(finalItem, 1);
            transparentMask.From = 0;
            blackMask.From = 0;

            //choosing direction
            opacityMask.StartPoint = new Point(0, 0);
            opacityMask.EndPoint = new Point(1, 0);

            waterBackground.OpacityMask = opacityMask;        
            

        }
        /// <summary>
        /// After every movement check, whether the new layout is a possible solution
        /// </summary>
        /// <returns></returns>
        private bool SolutionCheck()
        {
            PipeItem start = giveItemByCoordinate(0, 4); //solution check start from the Start item
            //as Start item is vertical, the next item will be the one, in the (0,3) coordinates
            int nextX = 0;
            int nextY = 3;

            int itemsInUse = 0;
            solutionList = new List<PipeItem>();
            solutionListOtherDirection = new List<PipeItem>();

            return (IsPossibleSolution(start, nextX, nextY, ref itemsInUse, solutionList, solutionListOtherDirection) && itemsInUse == gameLevel.PipeElementCount);        


        }
        /// <summary>
        /// Recursive method, which determines, whether water can flow through from the start item to the two finishing item
        /// </summary>
        /// <param name="previousItem"></param>
        /// <param name="nextX"></param>
        /// <param name="nextY"></param>
        /// <param name="itemCount"></param>
        /// <param name="itemList1"></param>
        /// <param name="itemList2"></param>
        /// <returns></returns>
        private bool IsPossibleSolution(PipeItem previousItem, int nextX, int nextY, ref int itemCount, List<PipeItem> itemList1, List<PipeItem> itemList2)
        {
            if ((nextX == 3 && nextY == 4 && previousItem.Posx == 3 && previousItem.PosY == 3)) //Coordinates of the finish item
            {
                itemList1.Add(giveItemByCoordinate(nextX, nextY));
                return true;
            }               
            else if ((nextX == 5 && nextY == 3 && previousItem.Posx == 4 && previousItem.PosY == 3)) //Coordinates of the finish item
                return true;
            else
            {
                if (giveItemByCoordinate(nextX, nextY) != null) //are there any PipeItem in the next coordinates
                {
                    PipeItem actualItemInSolution = giveItemByCoordinate(nextX, nextY);
                    //if there is a PipeItem in the next coordinates, check if it fits the previous item and also get its next possible coordinates, indicating, where the water will flow
                    int[] nextCoordinates = actualItemInSolution.possibleDirectionByPipeType(previousItem.Posx, previousItem.PosY);

                    if (nextCoordinates == null)
                        return false;
                    else
                    {
                        itemList1.Add(actualItemInSolution);
                        if (nextCoordinates.Length == 2) //actualItemInSolution is only a 2way item, with one incoming and one outgoing direction
                        {
                            itemCount++;
                            return IsPossibleSolution(actualItemInSolution, nextCoordinates[0], nextCoordinates[1], ref itemCount, itemList1, itemList2);
                        }
                        else
                        {
                            itemCount++;
                            return (IsPossibleSolution(actualItemInSolution, nextCoordinates[0], nextCoordinates[1], ref itemCount, itemList1, itemList2) && IsPossibleSolution(actualItemInSolution, nextCoordinates[2], nextCoordinates[3], ref itemCount, itemList2, itemList1));
                        }
                    }
                }
                else return false;
            }

        }
        /// <summary>
        /// This method returns a Pipeitem which connects to an Image object on the canvas
        /// x and y coordinates are used, to indicate position inside the grid layout
        ///
        /// </summary>
        /// <param name="x"></param>
        /// <param name="y"></param>
        /// <returns></returns>
        private PipeItem giveItemByCoordinate(int x, int y)
        {
            for (int i = 0; i < myCanvas.Children.Count; i++)
            {
                if (myCanvas.Children[i] is Image && itemDictionary.ContainsKey((Image)myCanvas.Children[i]))
                {
                    Image key = (Image)myCanvas.Children[i];
                    PipeItem item = itemDictionary[key];
                    if (item.Posx == x && item.PosY == y)
                        return item;
                }
            }
            return null;
        }
        /// <summary>
        /// Create finish item, which is not an actual Pipeitem. This is only visual, containing an Image object outside the game's canvas
        /// </summary>
        private void CreateFinishItem()
        {
            finalItem = new Image();
            myCanvas.Children.Add(finalItem);
            Canvas.SetTop(finalItem, rowStartingCoordinates[3] - 1);
            Canvas.SetLeft(finalItem, (columnStartingCoordinates[columnStartingCoordinates.Length - 1] + columnWidth));
            finalItem.Height = rowHeight;
            finalItem.Width = 140;
            finalItem.Stretch = Stretch.Fill;
            finalItem.HorizontalAlignment = HorizontalAlignment.Left;
            finalItem.VerticalAlignment = VerticalAlignment.Top;
            finalItem.Source = new BitmapImage(new Uri("Assets/finish1.png", UriKind.Relative));            

        }

        private void Window_Loaded(object sender, RoutedEventArgs e)
        {
            this.DataContext = gamewvm;
            gamewvm.MoveCount = 0;
        }

        private void EndMenu(object sender, RoutedEventArgs e)
        {
            this.Close();
        }

        
    }
    
}
